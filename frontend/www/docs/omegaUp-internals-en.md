Everything you wanted to know about omegaUp and were afraid to ask

## Frontend
When you make a submission, the first thing that happens is that the code, along with the contest alias, problem, and code language, is sent using HTTP POST to the API endpoint `/api/run/create/`, via the `OmegaUp.submit` method in `frontend/www/js/omegaup.js`. Once it reaches the server, nginx redirects it to HHVM which invokes `ApiCaller::httpEntryPoint()`. Just before that, the file `frontend/server/bootstrap.php` is loaded, which contains all the configuration, loads the necessary modules, initializes the database connection, etc. Then, an object called `Request` is created, which contains the representation of all the request parameters (such as the authentication cookie). Additionally, the URL path is tokenized, the `/api` is removed, and the array `['run', 'create']` is obtained. The first element of the array is the name of the controller to be invoked (in this case it would be `RunController`), and the second parameter would be the name of the method (`apiCreate`). All subsequent elements are treated as a series of name-value pairs and are added to the `Request`.

Once `RunController::apiCreate` is called, the authentication token that was set during login is validated (usually stored as a cookie, but the API can accept this token as part of the parameters sent by POST). At this point, the ID of the user making the request is also obtained. Then, it is validated that the user indeed has permission to make that submission: it is verified that all required elements (problem name and contest, language, and code) are present, that the problem is in the contest and that both are valid, that the contest time limit has not expired, that the user is not exceeding the maximum submission rate (1 submission per problem every 60 seconds), and finally that the contest is public or that the user has been explicitly added to the list of people who can view the contest. When in Lockdown mode, more checks are performed (for now, it is only verified that the submission was not made in practice mode). The penalty is calculated according to the contest policy (from the start of the contest, from the first time the problem is opened, or the penalty is completely omitted), a random GUID is generated, everything is added to the database, and the submission code is saved in a file with that same GUID in the filesystem. Finally, an HTTP request is sent to the grader to run the submission (by ID), and the GUID is sent as JSON to the browser.

## Grader, part 1
Grader has an embedded HTTPS server where it listens for requests to evaluate a submission, register a new runner, deregister it, and broadcast some information to all clients that have connected using WebSockets. The `omegaup.grader.Manager` class is responsible for dispatching requests based on the URL. To grade submissions, `omegaup.grader.Manager.grade(req)` is invoked (where `req` is the deserialized version of the JSON used for the submission) where the submission ID is looked up in the database, all necessary information about the submission, problem, contest, and user is rehydrated (courtesy of `omegaup.grader.GraderData.hydrateRun`), a `omegaup.grader.RunContext` is created that will have all the metadata of the submission, along with tracing information to measure performance, and finally it is sent to the queue router via `omegaup.grader.RunnerDispatcher.addRun`.

There are 8 default queues: urgent, slow urgent, contest, slow contest, normal, slow normal, rejudge, slow rejudge. By default, nothing goes to the urgent queues, but it can be configured that certain contests (like OMI or CONACUP) always go to the urgent queue, via the grader configuration file (`omegaup.conf`). If the submission was not made in practice mode, it goes to contest; otherwise, it goes to normal. Rejudge is only used if the "rejudge" button was used in the frontend or if a problem's cases were changed. Finally, the slow queues are filled with problems that, in the worst case, would take more than 30s to return a TLE. The queues are processed from left to right, but only a certain percentage of runners can be attending slow queues simultaneously (currently 50%) to prevent them from monopolizing.

The queue to which the submission will be sent is chosen either by explicit configuration (the syntax and details of how they operate are in `omegaup.grader.RoutingDescription`), and there it will wait until there is a free runner. Once there is at least one submission ready to be evaluated and at least one free Runner, the `omegaup.grader.RunnerDispatcher.dispatchLocked` method takes the highest priority submission possible from all the queues and an available Runner, notes the time they were taken from the queues (to detect dead Runners), and calls `omegaup.grader.RunnerDispatcher.GradeTask.gradeTask` in a thread pool. `gradeTask` invokes `omegaup.grader.drivers.OmegaUpDriver.run` to communicate directly with the Runners with a 10-minute deadline: if it is exceeded or there is an exception in processing, the Runner is considered dead, and if the error was not severe, the submission is requeued, hoping it was a temporary error.

## Runner
The Runners are in the cloud, on virtual machines. Each time one is turned on, it sends a registration request to the Grader, and it is added to the pool of available Runners, where they are dispatched round-robin (there is no affinity, but there was at some point in time, and it would not be complicated to add it back). After each minute of inactivity, it sends a new registration request to the Grader to notify it is still alive in case there is any complication or the Grader was restarted or whatever. Each Runner also has an embedded HTTPS server, so `omegaup.grader.drivers.OmegaUpDriver.run` communicates with `omegaup.runner.Service` via JSON over HTTPS. Although Grader has a queue to ensure that each Runner is being used by at most one submission, bad things can happen if there are network issues, so the Runner also has a mutex to ensure that only one submission is being processed at a time.

The whole process starts with `omegaup.runner.Runner.compile`, which uses calls to `omegaup.runner.Minijail` to encapsulate the logic of passing the appropriate flags to the compiler and `minijail`. Depending on which flags and fields were filled in to make the compilation request, it can compile one or several files (for the case of interactive problems). There is no explicit configuration of how things should be compiled, so only the convention that the main class is called `Main`, and the executable file produced is called `Main` (or `Main.class` in Java or its equivalent in other languages) is used. If this request was successful, a token is returned to the Grader (which is the path in the filesystem where the temporary files are stored), which must be sent in future requests to refer to the same compiled file. If the compilation failed, all temporary files are deleted, and the compiler's stderr is returned as a compilation error. If the problem has a registered validator, the validator is also sent in the message and compiled in this step.

To run a submission against a pre-established input, the Grader sends the compilation token along with the SHA-1 hash of the input cases in a .zip via JSON to the Runner. It is validated that the input is cached in the filesystem, and if not, an error is sent for the Grader to send the .zip in another request. Once it is validated that the set of input files is in the local filesystem, the executable is run with each `.in` file. The execution message, in addition to pre-established cases, can send standalone cases in the same request (as plain text), and those cases would also be evaluated as if they had come in the .zip with all the `.in` files. The execution message can also reference a validator (if the problem has one present). For each case (whether from the .zip or the message), the `.out` is saved along with the metadata, compressed using bzip2, and sent back to the Grader immediately. If there is a validator, the validator is also run against the user's `.out` and the original `.in`, and the results (`.out` and metadata) are also sent to the Grader. stderr and other things are only sent using debug-rejudge in the frontend.

Once the evaluation of all cases is complete, the temporary files are deleted, and the next message is processed.

## Grader, part 2
Once all the outputs for a submission are available, the Runner is released and returned to the pool where it can run the next submission. In parallel, `omegaup.grader.Grader` is invoked, which has all the logic for the different types of validators: all validators tokenize the stream using spaces as separators. Some validators (like token and token-caseless) check each token and give up at the first difference, or if one of the streams stops producing tokens and the other stream still has tokens. Other validators (like token-numeric) ignore all tokens that do not have a numeric format, interpret all numbers as floats, and make comparisons with tolerance. This produces a final verdict per case. Once all cases have a verdict, if the problem has a `/testplan` file, that file is parsed, and normalized weights are assigned (in the end, the sum of all weights must be equal to 1); otherwise, each case is worth 1 / number of cases. With the weights, the cases are grouped: everything before the first '.' in the file name is considered the group name (this means that if it does not have an explicit group, everything before the `.in` will be the implicit group name). A group is considered to award points only if all cases in the group had an AC or PA verdict. In the end, all group points are summed, and the result is multiplied by the number of points that problem gives for that contest (or 100% in practice mode). The final verdict is saved in the database, and the `RunContext` is enqueued in the Broadcaster.

## Broadcaster
Broadcaster is responsible for maintaining the contest scoreboard and notifying in near-real-time all contestants who have activated WebSockets mode. Each submission placed in the Broadcaster queue that was from a contest calls `/api/scoreboard/refresh` in the Frontend, which updates the scoreboard according to the contest policies. Once the scoreboard is updated and cached on the server, Broadcaster notifies all participants of that contest that the scoreboard has changed and the author of the submission of the verdict. Once it reaches that point, the `RunContext` saves information on how long it spent in each of the queues and how long the Runner took to respond, along with some more debugging information, and is destroyed.
